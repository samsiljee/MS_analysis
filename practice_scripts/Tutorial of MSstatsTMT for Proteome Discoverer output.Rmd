---
title: "Tutorial of MSstatsTMT - May 6"
subtitle: "Input to MSstatsTMT: PSM data from Proteome Discoverer"
author: "Ting Huang"
date: "5/6/2020"
output: 
  html_document:
    self_contained: true
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Objective

- Make annotation file, based on experimental design
- Preprocessing steps to make required input format for MSstatsTMT from output of Proteome Discoverer
- Global median normalization between channels
- Protein summarization
- Local protein-level normalization with reference channel.
- Statistical modeling and inference

***

# Data

- Controlled mixtures: Sigma UPS1 48 protein-mix were spiked at 4 different ratio into a SILAC-labelled HeLa lysate. The mixtures were measured by TMT 10-plexes.

- the peptide quantification data of controlled mixtures, processed by Proteome Discoverer.

![](img/Experimental_design.jpg)


***

# 1. Load MSstatsTMT

Load MSstatsTMT first. Then you are ready to start MSstatsTMT

```{r, eval=T, echo=T, warning=F, message=F}
# if (!requireNamespace("BiocManager", quietly = TRUE))
#     install.packages("BiocManager")
# 
# BiocManager::install("MSstatsTMT")

library(MSstatsTMT)
# version 1.4.6 and 1.6.0 work for this tutorial
?MSstatsTMT

# we also use another two pacakges for data manipulation
# install.packages(c("tidyr", "dplyr"))
library(tidyr)
library(dplyr)
```

MSstatsTMT includes the following three steps for statistical testing:

+ Converters for different peptide quantification tools to get the input with required format: PDtoMSstatsTMTFormat, MaxQtoMSstatsTMTFormat, SpectroMinetoMSstatsTMTFormat and OpenMStoMSstatsTMTFormat.
+ Protein summarization based on peptide quantification data: proteinSummarization
+ Group comparison on protein quantification data: groupComparisonTMT

***

# 2. Allowable data formats

`MSstatsTMT` performs statistical analysis steps, that follow peptide identification and quantitation. Therefore, input to MSstatsTMT is the output of other software tools (such as `Proteome Discoverer`, `MaxQuant` and so on) that read raw spectral files
, identify and quantify peptide ions. The preferred structure of data for use in MSstatsTMT is a .csv file in a *long* format with at least 9 columns representing the following variables: **ProteinName**, **PeptideSequence**, **Charge**, **PSM**, **Channel**, **Condition**, **BioReplicate**, **Mixture**, **Intensity**. The variable names are fixed, but are case-insensitive.

```{r, eval=T, echo=F, warning=F}
head(input.pd)
```

***

Let's start preprocessing steps to make required input format for MSstatsTMT from output of Proteome Discoverer.


# 3. Proteome Discoverer converter

## 3.1 Read data

The required input data is the PSM-level data generated by `Proteome Discoverer`.
We first load and access the dataset processed by `Proteome Discoverer`. 
```{r}
# Read output from Proteome Discoverer 
raw.pd <- read.delim("data/data_ProteomeDiscoverer_TMT/spikedin_PSMs.txt")
```

```{r}
# Check the column names
colnames(raw.pd)
```

The column names are differently from required input. Let's do preliminary check for this input.

```{r}
# total number of unique protein name
length(unique(raw.pd$Protein.Accessions))

# show the spiked-in proteins
unique(raw.pd[grepl("ups", raw.pd$Protein.Accessions),]$Protein.Accessions)

# total number of unique peptide names
length(unique(raw.pd$Annotated.Sequence))

# unique Spectrum.File, which is TMT run.
unique(raw.pd$Spectrum.File)
```


## 3.2. Set annotation file

Annotation information is required to fill in **Condition**, **Mixture**, **TechRepMixture**, **Fraction**, and **BioReplicate** for corresponding **Run** and **Channel** information. Users have to prepare as csv or txt file like 'data_ProteomeDiscoverer_TMT/PD_Annotation.csv', which includes **Run**, **Channel**, **Condition**, **BioReplicate**, **Mixture**, **TechRepMixture** and **Fraction**  information, and load it in R.

```{r}
annot.pd <- read.csv(file="data/data_ProteomeDiscoverer_TMT/PD_Annotation.csv")
dim(annot.pd)

head(annot.pd)
```

`MSstatsTMT` can make inference for group comparison design. In a group comparison design, the conditions (e.g., disease states) are profiled across **non-overlapping sets of biological replicates (i.e., subjects)**. In this example there are 4 conditions, 0.125, 0.5, 0.667, 1 (in general the number of conditions can vary). There are 2 subjects (i.e., biological replicates) per condition per MS run (in general an equal number of replicates per condition is not required). Besides 2 pooled control replicates per run for across TMT-plex normalizations. Totally, each mixture has 10 replicates. There are 5 mixtures and each mixture has 3 technical replicate runs (in general technical replicates are not required, and their number per sample may vary). Overall, in this example there are 5 × 3 = 15 mass spectrometry runs and 5 × 3 x 10 = 150 replicates.

 `Mixture` | `TechRepMixture` | `Fraction` |  `Run` 
-----------|------------------|------------|---------
	1        |       1          |     F1     |    161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01.raw
	1        |       2          |     F1     |    161117_SILAC_HeLa_UPS1_TMT10_Mixture1_02.raw
	1        |       3          |     F1     |    161117_SILAC_HeLa_UPS1_TMT10_Mixture1_03.raw
	2        |       1          |     F1     |    161117_SILAC_HeLa_UPS1_TMT10_Mixture2_01.raw
	2        |       2          |     F1     |    161117_SILAC_HeLa_UPS1_TMT10_Mixture2_02.raw
	2        |       3          |     F1     |    161117_SILAC_HeLa_UPS1_TMT10_Mixture2_03.raw
	3        |       1          |     F1     |    161117_SILAC_HeLa_UPS1_TMT10_Mixture3_01.raw
	3        |       2          |     F1     |    161117_SILAC_HeLa_UPS1_TMT10_Mixture3_02.raw
	3        |       3          |     F1     |    161117_SILAC_HeLa_UPS1_TMT10_Mixture3_03.raw
	4        |       1          |     F1     |    161117_SILAC_HeLa_UPS1_TMT10_Mixture4_01.raw
	4        |       2          |     F1     |    161117_SILAC_HeLa_UPS1_TMT10_Mixture4_02.raw
	4        |       3          |     F1     |    161117_SILAC_HeLa_UPS1_TMT10_Mixture4_03.raw
	5        |       1          |     F1     |    161117_SILAC_HeLa_UPS1_TMT10_Mixture5_01.raw
	5        |       2          |     F1     |    161117_SILAC_HeLa_UPS1_TMT10_Mixture5_02.raw
	5        |       3          |     F1     |    161117_SILAC_HeLa_UPS1_TMT10_Mixture5_03.raw

We know all the runs of one Mixture have same **Condition** and **BioReplicate** information. Here show Mixture **1** as an example,

`Mixutre`|  `Channel` | `BioReplicate` | `Condition`
---------|------------|----------------|-----------
	1      |		127C    |     0.125      |    0.125
	1      |		129N    |     0.125      |    0.125
	1      |		128N    |     0.5        |    0.5
	1      |		129C    |     0.5        |    0.5
	1      |		127N    |     0.667      |    0.667
	1      |		130C    |     0.667      |    0.667
	1      |		128C    |     1          |    1
	1      |		130N    |     1          |    1
	1      |		126     |     Norm       |    Norm
	1      |		131     |     Norm       |    Norm

The detailed explanation about the columns in the annotation file is that 

+ Run : MS run ID. It should be the same as Spectrum.File info in output of `Proteome Discoverer`.
+ Channel : Labeling information (126, ... 131). It should be consistent with the channel columns in output of `Proteome Discoverer`.
+ Condition : Condition (ex. Healthy, Cancer, Time0). If the channal doesn’t have sample, please add `Empty` under `Condition`.
+ Mixture : Mixture of samples labeled with different TMT reagents, which can be analyzed in a single mass spectrometry experiment. 
+ TechRepMixture : Technical replicate of one mixture. One mixture may have multiple technical replicates. For example, if `TechRepMixture` = 1, 2 are the two technical replicates of one mixture, then they should match with same `Mixture` value.
+ Fraction : Fraction ID. One technical replicate of one mixture may be fractionated into multiple fractions to increase the analytical depth. Then one technical replicate of one mixture should correspond to multuple fractions. For example, if `Fraction` = 1, 2, 3 are three fractions of the first technical replicate of one TMT mixture of biological subjects, then they
should have same `TechRepMixture` and `Mixture` value.
+ BioReplicate : Unique ID for biological subject. If the channal doesn’t have sample, please add `Empty` under `BioReplicate`.

### 3.2.1 Fill in run information for each MS run

Let's check the **Spectrum.File** in output of `Proteome Discoverer`.

```{r}
runs <- unique(raw.pd$Spectrum.File) # MS runs
Run_info <- data.frame(Run = runs) # initialize the run file 
Run_info

Run_info$Mixture <- ""
Run_info$TechRepMixture <- ""
Run_info$Fraction <- ""

## save the channel file and fill in the condition and biological replicate information manually
write.csv(Run_info, file = "data/data_ProteomeDiscoverer_TMT/Run_info.csv", row.names = FALSE)
```

We first need to add the **Mixture**, **TechRepMixture** and **Fraction** information for each **Run**

```{r}
## Now the run information should be available in the file
Run_info_filled <- read.csv(file = "data/data_ProteomeDiscoverer_TMT/Run_info_filled.csv")
head(Run_info_filled)
```

### 3.2.2 Fill in biological information for each subject

We then need to add the **Condition** and **BioReplicate** information for each **Mixture** and **Channel**

```{r, message=F, warning=F}
colnames(raw.pd)

channels <- c("126", "127N", "127C", "128N", "128C", "129N", "129C", "130N", "130C", "131")
mixtures <- unique(Run_info_filled$Mixture)
mixtures

## create the file with channel information in each mixture
Group_info <- expand.grid(channels, mixtures)
colnames(Group_info) <- c("Channel", "Mixture")
head(Group_info)

Group_info$Condition <- ""
Group_info$BioReplicate <- ""

## save the channel file and fill in the condition and biological replicate information manually
write.csv(Group_info, file = "data/data_ProteomeDiscoverer_TMT/Group_info.csv", row.names = FALSE)

## Now the condition information should be available in the file
Group_info_filled <- read.csv(file = "data/data_ProteomeDiscoverer_TMT/Group_info_filled.csv")
head(Group_info_filled)
```

### 3.2.3 combine run information and biological information

```{r, message=F, warning=F}
annotation <- full_join(Run_info_filled, Group_info_filled)
dim(annotation)

head(annotation)
```

## 3.3. Preprocessing with `PDtoMSstatsTMTFormat`

The input data for `MSstatsTMT` is required to contain variables of **ProteinName**, **PeptideSequence**, **Charge**, **PSM**, **Channel**, **Condition**, **BioReplicate**, **Mixture**, **Intensity**. These variable names should be fixed. Output from Proteome Discoverer have different columns from the required input of `MSstatsTMT`.  `PDtoMSstatsTMTFormat ` function helps pre-processing for making right format of MSstatsTMT input from Proteome Discoverer output. For example, it renames some column name, and remove shared peptides. 

Here is the summary of pre-processing steps in `PDtoMSstatsTMTFormat` function.

+ Peptide ions which are shared by more than one protein are removed
+ If one spectrum has multiple identifications within one run, it only keeps the best identification with the minimal number of missing reporter ion intensities, highest reporter ion intensity, or lowest interference score if the information was available
+ If a spectrum only has one or two reporter ion intensities within one MS run, it removes the spectrum from that run
+ Ambiguous protein groups which contained multiple proteins were filtered out
+ For fractionation, If a peptide ion was shared by multiple fractions, we kept the fraction with maximal average reporter ion abundance across all the channel in the fraction.


For further details, visit the help file using the following code.
```{r, eval=F}
?PDtoMSstatsTMTFormat
```


```{r, message=F, warning=F}
# reformating and pre-processing for PD output.
input.pd <- PDtoMSstatsTMTFormat(input = raw.pd, annotation = annotation)
head(input.pd)
```

## 3.4 Preliminary check

```{r}
length(unique(input.pd$ProteinName)) 
# show the spiked-in proteins
unique(input.pd[grepl("ups",input.pd$ProteinName),]$ProteinName)
```

***

# 4. Normalizing and summarizing data with proteinSummarization
**! Always pay attention to the default options **  

After reading the datasets, `MSstatsTMT` performs 

* 1) logarithm transformation of `Intensity` column

* 2) global median normalization between channels

* 3) channel-level protein summarization

* 4) Local protein-level normalization with reference channel

To get started with this function, visit the help section of `proteinSummarization ` first: 

```{r,eval=FALSE}
?proteinSummarization 
```

## 4.1 Default summarization and normalization options

`proteinSummarization` perform first (1) global_norm = FALSE: a global equal median normalization between channels will be performed to account for differences in labeling efficiency and other techinical artifacts.

Then, (2) method = "msstats": missing value imputation and protein summarization will be performed, which is robust parameter estimation by TMP (Tukey's median polish).

Last, (3) reference_norm = TRUE: normalization between MS runs. It needs at least one normalization channel in each MS run, annotated by 'Norm' in Condition column. If there are multiple normalization channels, all the normalization channels are averaged for the normalization. FALSE will not perform normalization step.

Below show the default for all options in proteinSummarization.

```{r, message=F, warning=F, results='hide'}
# use MSstats for protein summarization
quant.pd <- proteinSummarization(input.pd,
                                 method="msstats",
                                 global_norm=FALSE,
                                 reference_norm=TRUE,
                                 remove_norm_channel = FALSE,
                                 remove_empty_channel = TRUE)

# This table includes normalized channel-level log2 intensities. (column : Abundance)
# Now one summarized log2 intensities per Protein, Run, Channel.
head(quant.pd)
```

```{r, message=F, warning=F}
save(quant.pd, file='data/data_ProteomeDiscoverer_TMT/quant.pd.rda')
```

***

# 5. Visualization of protein summaries

Profile plot is good visualization to check individual measurements. Each dot means one intensity per Run per Channel. Each panel represents one MS run and each dot within one panel is one channel within one Run. The dots are linked with line per feature. If line is disconnected, that means there is no value (missing value). Color means different peptides and charge stages. 

```{r, message=F, warning=F}
# if you have many MS runs, adjust width of plot (make wider)
# Profile plot for the normalized data 
dataProcessPlotsTMT(data.peptide = input.pd, # PSM-level data
                    data.summarization = quant.pd, # protein-level data
                    type = 'ProfilePlot', # choice of visualization
                    width = 21,
                    height = 7,
                    address="data/data_ProteomeDiscoverer_TMT/pd_norm_") 
```

`pd_norm_ProfilePlot.pdf` and `pd_norm_ProfilePlot_wSummarization.pdf` are generated in the current directory.

Then, Let's go though profile plots to see overall quality of data. There are two pdfs for each protein, first is profile plot and second plot is profile plot with summarized and normalized data. `pd_norm_ProfilePlot.pdf` shows each peptide ions across runs and channels, grouped per condition. Each peptide has a different colour/type layout. `pd_norm_ProfilePlot_wSummarization.pdf` shows the same peptide ions in grey, with the values as summarized by the model overlayed in red.

Instead of making all profile plots for all proteins, we can make plot for individual protein. Here is the example of background protein, `O75844`
```{r, message=F, warning=F}
dataProcessPlotsTMT(data.peptide = input.pd, # PSM-level data
                    data.summarization = quant.pd, # protein-level data
                    type='ProfilePlot', # choice of visualization
                    width = 21,
                    height = 7,
                    which.Protein = 'P35221',
                    address="data/data_ProteomeDiscoverer_TMT/pd_norm_P35221_") 
```

![](data/data_ProteomeDiscoverer_TMT/pd_norm_P35221_ProfilePlot.jpg)

![](data/data_ProteomeDiscoverer_TMT/pd_norm_P35221_ProfilePlot_wSummarization.jpg)

***

# 6. Different parameter options for summarization and normalization

## 6.1. No normalization
No normalization is performed. If you don't want to do any normalization, you should use like below.
```{r, message=F, warning=F, results='hide'}
quant.pd.nonorm <- proteinSummarization(data = input.pd,
                                       global_norm = FALSE,
                                       reference_norm = FALSE,
                                       remove_norm_channel = FALSE,
                                       remove_empty_channel = TRUE)

# Profile plot for the data without normalization
dataProcessPlotsTMT(data.peptide = input.pd, # PSM-level data
                    data.summarization = quant.pd.nonorm, # protein-level data
                    type = 'ProfilePlot', # choice of visualization
                    width = 21,
                    height = 7,
                    originalPlot = FALSE,
                    which.Protein = 'P35221',
                    address="data/data_ProteomeDiscoverer_TMT/pd_noNorm_P35221_")

```

![](data/data_ProteomeDiscoverer_TMT/pd_noNorm_P35221_ProfilePlot_wSummarization.jpg)

## 6.2. Different summarization option

MSstatsTMT provides four different summarization methods for protein quantification. `msstats` is default, which we have used before. Now let's try another robust summarization method `Median`.

```{r, message=F, warning=F, results='hide'}
quant.pd.median <- proteinSummarization(data = input.pd,
                                        method = "Median", 
                                        global_norm = FALSE,
                                        reference_norm = FALSE,
                                        remove_norm_channel = FALSE,
                                        remove_empty_channel = TRUE)

dataProcessPlotsTMT(data.peptide = input.pd, # PSM-level data
                    data.summarization=quant.pd.median, # protein-level data
                    type='ProfilePlot', # choice of visualization
                    width = 21,
                    height = 7,
                    originalPlot = FALSE,
                    which.Protein = 'P35221',
                    address="data/data_ProteomeDiscoverer_TMT/pd_median_P35221_") 
```

![](data/data_ProteomeDiscoverer_TMT/pd_median_P35221_ProfilePlot_wSummarization.jpg)

***

# 7. Finding differentially abundant proteins across conditions

After we summarized each protein's behavior across conditions and normalized the data between runs in `proteinSummarization` step, we are all set to compare protein changes between groups of conditions. Within MSstatsTMT we can do this with the `groupComparisonTMT` function, which takes as input the output of the `proteinSummarization` function. 

```{r}
?groupComparisonTMT
```

## 7.1.Pairwise comparison

If you want to make all the pairwise comparison,`MSstatsTMT` has an easy option for it. Setting `contrast.matrix = pairwise` compares all the possible pairs between two conditions.

```{r, message=F, warning=F}
quant.pd <- quant.pd %>%  filter(Condition != "Norm")

test.pd.pairwise <- groupComparisonTMT(data = quant.pd, 
                               contrast.matrix = "pairwise",
                               moderated = TRUE, # do moderated t test
                               adj.method = "BH") # multiple comparison adjustment

# show the comparisons
unique(test.pd.pairwise$Label)
```

Let's check the output.

```{r, eval=TRUE}
colnames(test.pd.pairwise)

# Show test result
# Label : which comparison is used
# log2FC : estimated log2 fold change between two conditions (the contrast)
# adj.pvalue : adjusted p value
head(test.pd.pairwise)
```

Let's save the testing result as .csv file.

```{r, eval=T, message=F, warning=F}
save(test.pd.pairwise, file='data/data_ProteomeDiscoverer_TMT/pd.result.rda')
write.csv(test.pd.pairwise, file='data/data_ProteomeDiscoverer_TMT/testResult_pd.csv')
```

## 7.2 Volcano plot

Let's inspect the results to see what proteins are changing significantly between two concentrations.

```{r, eval=TRUE}
library(MSstats)

groupComparisonPlots(data=test.pd.pairwise, 
                     type="VolcanoPlot", 
                     logBase.pvalue=2, 
                     ProteinName=TRUE, # only for small protein number
                     address="data/data_ProteomeDiscoverer_TMT/pd_pairwise_")
```

![](data/data_ProteomeDiscoverer_TMT/VolcanoPlot-0.5-0.667.jpg)

![](data/data_ProteomeDiscoverer_TMT/VolcanoPlot-0.125-0.5.jpg)

## 7.3 Assign contrast matrix

If you would like to compare some specific combination of conditions, you need to tell `groupComparisonTMT` the contrast of the conditions to compare. You can make your `contrast.matrix` in R in a text editor. We define our contrast matrix by adding a column for every condition. We add a row for every comparison we would like to make between groups of conditions.  

**0** is for conditions we would like to ignore.
**1** is for conditions we would like to put in the numerator of the ratio or fold-change.
**-1** is for conditions we would like to put in the denumerator of the ratio or fold-change.

If you have multiple groups, you can assign any group comparisons you are interested in.

```{r, message=F, warning=F}
# check unique conditions and check order of condition information
# In this case, four different concentrations
unique(quant.pd$Condition)

# 'Norm' will be removed during tesing and should be not considered in the contrast
comparison1<-matrix(c(-1,0,0,1),nrow=1) # 0.5-0.125
comparison2<-matrix(c(0,-1,1,0),nrow=1) # 0.667-0.5
comparison<-rbind(comparison1, comparison2)
# Set the column names
colnames(comparison)<- c("0.125", "0.5", "0.667", "1")
# Set the names of each row
row.names(comparison)<-c("1-0.125","0.667-0.5")

comparison

test.pd <- groupComparisonTMT(data = quant.pd, 
                               contrast.matrix = comparison,
                               moderated = TRUE, # do moderated t test
                               adj.method = "BH") # multiple comparison adjustment
```

# 8. msstatstmt.log and sessionInfo.txt

These two files are important to keep the records of package versions and options in functions.
